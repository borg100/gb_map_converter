using System;
using CommandLine;
using System.Diagnostics;
using System.Text;
using System.IO;
using System.Drawing;
using System.Text.RegularExpressions;
using System.Reflection;

namespace gb_map_converter
{
    class Program
    {
        private static readonly StringBuilder ProcessErrors = new StringBuilder();
        private static readonly StringBuilder ProcessOutput = new StringBuilder();

        private const string TempTilesFile = "_tiles.tmp";
        private const string TempMapFile = "_map.tmp";
        private const string TempPaletteFile = "_palette.tmp";

        private const int Tiles_BytesPerLine = 8;
        private const int Map_BytesPerLine = 16;

        private const bool HideIntellisenceErrors = true;

        public static string HeaderString
        {
            get
            {
                var v = Assembly.GetEntryAssembly().GetName().Version;
                return $"Generated by gb_map_converter v{v.Major}.{v.Minor}.";
            }
        }

        public class Options
        {
            [Option('i', "input", Required = true, HelpText = "Input image to be converted.")]
            public string InputFile { get; set; }
            [Option('o', "output", Required = false, HelpText = "Output folder to place converted files.")]
            public string OutputFolder { get; set; }
            [Option('n', "name", Required = false, HelpText = "Name to use for converted files and variables.")]
            public string Name { get; set; }
            [Option('t', "tiles", Required = false, HelpText = "Create a tiles image file.", Default = false)]
            public bool TileOutput { get; set; }
            [Option('p', "palette", Required = false, HelpText = "Create a palette image file.", Default = false)]
            public bool PaletteOutput { get; set; }
            [Option('b', "bank", Required = false, HelpText = "Specify bank number. Use 0 to disable.", Default = 255)]
            public int Bank { get; set; }
            [Option('l', "lower", Required = false, HelpText = "Use lowercase variables instead of uppercase.", Default = false)]
            public bool LowercaseVariables { get; set; }
            [Option('v', "verbose", Required = false, HelpText = "Show more information.", Default = false)]
            public bool Verbose { get; set; }
        }

        static bool Execute(Options options, string fileName, string arguments)
        {
            Console.WriteLine($"Executing: {fileName} {arguments}");

            var process = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = fileName,
                    Arguments = arguments,
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    CreateNoWindow = true
                }
            };
            ProcessOutput.Clear();
            ProcessErrors.Clear();
            process.OutputDataReceived += Process_OutputDataReceived;
            process.ErrorDataReceived += Process_ErrorDataReceived;
            process.Start();
            process.BeginOutputReadLine();
            process.BeginErrorReadLine();
            process.WaitForExit();

            if (options.Verbose)
            {
                Console.Write(ProcessOutput.ToString());
            }

            return process.ExitCode == 0;
        }

        static void AppendHeader(StringBuilder sb, string outputPath)
        {
            sb.AppendLine("/*");
            sb.AppendLine($"{"",4}{Path.GetFileName(outputPath).ToUpper()}");
            sb.AppendLine($"{"",4}{HeaderString}");
            sb.AppendLine("*/");
            sb.AppendLine();
        }

        static void AppendBank(StringBuilder sb, int bank, string variableName)
        {
            if (bank > 0)
            {
                sb.AppendLine($"#pragma bank {bank}");
                if (HideIntellisenceErrors)
                {
                    sb.AppendLine("#ifndef __INTELLISENSE__");
                }
                sb.AppendLine($"const void __at({bank}) __bank_{variableName};");
                if (HideIntellisenceErrors)
                {
                    sb.AppendLine("#endif");
                }
                sb.AppendLine();
            }
        }

        static void Run(Options options)
        {
            string outputPath;

            // Validate option: InputFile
            if (!File.Exists(options.InputFile))
            {
                Console.WriteLine("ERROR: The input image does not exist.");
                return;
            }

            // Validate image.
            var image = Image.FromFile(options.InputFile);
            if (image.Width % 8 != 0 || image.Height % 8 != 0)
            {
                Console.WriteLine("ERROR: The input image width and height have to be multiples of 8.");
                return;
            }
            var mapWidth = image.Width / 8;
            var mapHeight = image.Height / 8;

            // Validate option: OutputFolder
            if (string.IsNullOrWhiteSpace(options.OutputFolder))
            {
                options.OutputFolder = Directory.GetCurrentDirectory();
            }
            if (!Directory.Exists(options.OutputFolder))
            {
                Console.WriteLine("ERROR: The output folder does not exist.");
                return;
            }

            // Validate option: Name
            if (string.IsNullOrWhiteSpace(options.Name))
            {
                options.Name = Path.GetFileNameWithoutExtension(options.InputFile);
            }
            options.Name = options.Name.ToLower();
            if (char.IsDigit(options.Name[0]) || !Regex.IsMatch(options.Name, "^[a-z0-9_]*$"))
            {
                Console.WriteLine("ERROR: The name cannot start with a number and can only contain letters, numbers, and underscores.");
                return;
            }

            // Generate tile image
            outputPath = Path.Combine(options.OutputFolder, $"{options.Name}_tiles.png");
            if (options.TileOutput && !Execute(options, "superfamiconv.exe", $"-i \"{options.InputFile}\" -F -M gb --out-tiles-image \"{outputPath}\""))
            {
                Console.WriteLine("ERROR: Tile image creation failed:");
                Console.Write(ProcessErrors.ToString());
                return;
            }

            // Generate palette image
            outputPath = Path.Combine(options.OutputFolder, $"{options.Name}_palette.png");
            if (options.PaletteOutput && !Execute(options, "superfamiconv.exe", $"-i \"{options.InputFile}\" -F -M gb --out-palette-image \"{outputPath}\""))
            {
                Console.WriteLine("ERROR: Palette image creation failed:");
                Console.Write(ProcessErrors.ToString());
                return;
            }

            // Generate tile data
            if (!Execute(options, "superfamiconv.exe", $"-i \"{options.InputFile}\" -v -M gb -t \"{TempTilesFile}\""))
            {
                Console.WriteLine("ERROR: Tile conversion failed:");
                Console.Write(ProcessErrors.ToString());
                return;
            }

            // Generate map data
            if (!Execute(options, "superfamiconv.exe", $"-i \"{options.InputFile}\" -v -M gb -m \"{TempMapFile}\""))
            {
                Console.WriteLine("ERROR: Map conversion failed:");
                Console.Write(ProcessErrors.ToString());
                return;
            }

            // Generate palette data
            if (!Execute(options, "superfamiconv.exe", $"-i \"{options.InputFile}\" -F -M gb -p \"{TempPaletteFile}\""))
            {
                Console.WriteLine("ERROR: Palette conversion failed:");
                Console.Write(ProcessErrors.ToString());
                return;
            }

            // Read the palette byte.
            byte paletteByte;
            using (var reader = new FileStream(TempPaletteFile, FileMode.Open))
            {
                paletteByte = (byte)reader.ReadByte();
            }
            File.Delete(TempPaletteFile);


            int byteCount;
            var sb = new StringBuilder();
            string variableName;

            #region TILES.C
            sb.Clear();

            outputPath = Path.Combine(options.OutputFolder, $"{options.Name}_tiles.c");
            variableName = $"{options.Name}_TILE_DATA";
            variableName = options.LowercaseVariables ? variableName.ToLower() : variableName.ToUpper();

            AppendHeader(sb, outputPath);
            AppendBank(sb, options.Bank, variableName);

            using (var reader = new FileStream(TempTilesFile, FileMode.Open))
            {
                byteCount = (int)reader.Length;
                sb.AppendLine($"const unsigned char {variableName}[] = {{");
                int b;
                for (var i = 0; (b = reader.ReadByte()) != -1; i++)
                {
                    if (i % Tiles_BytesPerLine == 0)
                    {
                        if (i > 0)
                        {
                            sb.AppendLine(",");

                        }
                        if (i % 16 == 0)
                        {
                            sb.AppendLine($"{"",4}// Tile {i / 16}");
                        }
                        sb.Append($"{"",4}");
                    }
                    else
                    {
                        sb.Append(", ");
                    }
                    sb.Append($"0x{b:X2}");

                }
                sb.AppendLine();
                sb.AppendLine("};");
            }
            File.Delete(TempTilesFile);
            WriteToFile(outputPath, sb);
            #endregion

            #region TILES.H
            sb.Clear();

            outputPath = Path.Combine(options.OutputFolder, $"{options.Name}_tiles.h");
            variableName = $"{options.Name.ToUpper()}_TILE_DATA";
            variableName = options.LowercaseVariables ? variableName.ToLower() : variableName.ToUpper();

            AppendHeader(sb, outputPath);

            // Include Guard
            sb.AppendLine($"#ifndef __MAP_{Path.GetFileName(outputPath).ToUpper().Replace(".", "_")}__");
            sb.AppendLine($"#define __MAP_{Path.GetFileName(outputPath).ToUpper().Replace(".", "_")}__");
            sb.AppendLine();

            // Number of Tiles (Sets of 16 bytes)
            sb.AppendLine($"#define {options.Name.ToUpper()}_TILE_COUNT {byteCount / 16}");
            sb.AppendLine();

            // Palette
            sb.AppendLine($"#define {options.Name.ToUpper()}_PALETTE 0x{paletteByte:X2}");
            sb.AppendLine();

            // Bank Number
            sb.AppendLine($"extern const void __bank_{variableName};");
            sb.AppendLine();

            // Tile Data
            sb.AppendLine($"extern const unsigned char {variableName}[];");
            sb.AppendLine();

            // Include Guard
            sb.AppendLine("#endif");

            WriteToFile(outputPath, sb);
            #endregion

            #region MAP.C
            sb.Clear();

            outputPath = Path.Combine(options.OutputFolder, $"{options.Name}_map.c");
            variableName = $"{options.Name.ToUpper()}_MAP_DATA";
            variableName = options.LowercaseVariables ? variableName.ToLower() : variableName.ToUpper();

            AppendHeader(sb, outputPath);
            AppendBank(sb, options.Bank, variableName);

            using (var reader = new FileStream(TempMapFile, FileMode.Open))
            {
                sb.AppendLine($"const unsigned char {variableName}[] = {{");
                int b;
                for (var i = 0; (b = reader.ReadByte()) != -1; i++)
                {
                    if (i % Map_BytesPerLine == 0)
                    {
                        if (i > 0)
                        {
                            sb.AppendLine(",");
                        }
                        sb.Append($"{"",4}");
                    }
                    else
                    {
                        sb.Append(", ");
                    }
                    sb.Append($"0x{b:X2}");

                }
                sb.AppendLine();
                sb.AppendLine("};");
            }
            File.Delete(TempMapFile);
            WriteToFile(outputPath, sb);
            #endregion

            #region MAP.H
            sb.Clear();

            outputPath = Path.Combine(options.OutputFolder, $"{options.Name}_map.h");
            variableName = $"{options.Name.ToUpper()}_MAP_DATA";
            variableName = options.LowercaseVariables ? variableName.ToLower() : variableName.ToUpper();

            AppendHeader(sb, outputPath);

            // Include Guard
            sb.AppendLine($"#ifndef __MAP_{Path.GetFileName(outputPath).ToUpper().Replace(".", "_")}__");
            sb.AppendLine($"#define __MAP_{Path.GetFileName(outputPath).ToUpper().Replace(".", "_")}__");
            sb.AppendLine();

            // Map Dimensions (Number of tiles)
            sb.AppendLine($"#define {options.Name.ToUpper()}_MAP_WIDTH {mapWidth}");
            sb.AppendLine($"#define {options.Name.ToUpper()}_MAP_HEIGHT {mapHeight}");
            sb.AppendLine();

            // Bank Number
            sb.AppendLine($"extern const void __bank_{variableName};");
            sb.AppendLine();

            // Map Data
            sb.AppendLine($"extern const unsigned char {variableName}[];");
            sb.AppendLine();

            // Include Guard
            sb.AppendLine("#endif");

            WriteToFile(outputPath, sb);
            #endregion
        }

        private static void WriteToFile(string filePath, StringBuilder sb)
        {
            if (File.Exists(filePath))
            {
                File.Delete(filePath);
            }
            using (var writer = new StreamWriter(new FileStream(filePath, FileMode.CreateNew)))
            {
                writer.Write(sb.ToString());
            }
        }

        private static void Process_OutputDataReceived(object sender, DataReceivedEventArgs e)
        {
            ProcessOutput.AppendLine(e.Data);
        }

        private static void Process_ErrorDataReceived(object sender, DataReceivedEventArgs e)
        {
            ProcessErrors.AppendLine(e.Data);
        }

        static void Main(string[] args)
        {
            Parser.Default.ParseArguments<Options>(args)
                   .WithParsed(options => { Run(options); });
        }
    }
}
