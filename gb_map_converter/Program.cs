using System;
using CommandLine;
using System.Diagnostics;
using System.Text;
using System.IO;
using System.Drawing;
using System.Text.RegularExpressions;
using System.Reflection;

namespace gb_map_converter
{
    class Program
    {
        private static readonly StringBuilder ProcessErrors = new StringBuilder();
        private static readonly StringBuilder ProcessOutput = new StringBuilder();

        private const string TempTilesFile = "_tiles.tmp";
        private const string TempMapFile = "_map.tmp";

        private const int Tiles_BytesPerLine = 8;
        private const int Map_BytesPerLine = 16;

        public static string HeaderString
        {
            get
            {
                var v = Assembly.GetEntryAssembly().GetName().Version;
                return $"Generated by gb_map_converter v{v.Major}.{v.Minor}.";
            }
        }

        public class Options
        {
            [Option('i', "input", Required = true, HelpText = "Input image to be converted.")]
            public string InputFile { get; set; }
            [Option('o', "output", Required = false, HelpText = "Output folder to place converted files.")]
            public string OutputFolder { get; set; }
            [Option('n', "name", Required = false, HelpText = "Name to use for converted files and variables.")]
            public string Name { get; set; }
            [Option('t', "tiles", Required = false, HelpText = "Create a _tiles.png file.")]
            public bool TileOutput { get; set; }
            [Option('p', "palette", Required = false, HelpText = "Create a _palette.png file.")]
            public bool PaletteOutput { get; set; }
        }

        static bool Execute(string fileName, string arguments)
        {
            var process = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = fileName,
                    Arguments = arguments,
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    CreateNoWindow = true
                }
            };
            ProcessOutput.Clear();
            ProcessErrors.Clear();
            process.OutputDataReceived += Process_OutputDataReceived;
            process.ErrorDataReceived += Process_ErrorDataReceived;
            process.Start();
            process.BeginOutputReadLine();
            process.BeginErrorReadLine();
            process.WaitForExit();

            Console.Write(ProcessOutput.ToString());

            return process.ExitCode == 0;
        }

        static void AddHeader(StringBuilder sb, string outputPath, bool autobank = false, bool hideErrors = true)
        {
            sb.AppendLine("/*");
            sb.AppendLine($"{"",4}{Path.GetFileName(outputPath).ToUpper()}");
            sb.AppendLine($"{"",4}{HeaderString}");
            sb.AppendLine("*/");
            sb.AppendLine();
            if (autobank)
            {
                sb.AppendLine("#pragma bank 255");
                if (hideErrors)
                {
                    sb.AppendLine("#ifndef __INTELLISENSE__");
                }
                sb.AppendLine($"const void __at(255) __bank_{Path.GetFileNameWithoutExtension(outputPath).ToLower()};");
                if (hideErrors)
                {
                    sb.AppendLine("#endif");
                }
                sb.AppendLine();
            }
        }

        static void Run(Options o)
        {
            // Input File
            if (!File.Exists(o.InputFile))
            {
                Console.WriteLine("ERROR: The input image does not exist.");
                return;
            }
            var image = Image.FromFile(o.InputFile);
            if (image.Width % 8 != 0 || image.Height % 8 != 0)
            {
                Console.WriteLine("ERROR: The input image width and height have to be multiples of 8.");
                return;
            }
            var mapWidth = image.Width / 8;
            var mapHeight = image.Height / 8;

            // Output Folder
            if (string.IsNullOrWhiteSpace(o.OutputFolder))
            {
                o.OutputFolder = Directory.GetCurrentDirectory();
            }
            if (!Directory.Exists(o.OutputFolder))
            {
                Console.WriteLine("ERROR: The output folder does not exist.");
                return;
            }

            // Name
            if (string.IsNullOrWhiteSpace(o.Name))
            {
                o.Name = Path.GetFileNameWithoutExtension(o.InputFile);
            }
            o.Name = o.Name.ToLower();
            if (char.IsDigit(o.Name[0]) || !Regex.IsMatch(o.Name, "^[a-z0-9_]*$"))
            {
                Console.WriteLine("ERROR: The name cannot start with a number and can only contain letters, numbers, and underscores.");
                return;
            }

            if (o.TileOutput && !Execute("superfamiconv.exe", $"-i \"{o.InputFile}\" -F -M gb --out-tiles-image \"_tiles.png\""))
            {
                Console.WriteLine("ERROR: Tile image creation failed:");
                Console.Write(ProcessErrors.ToString());
                return;
            }

            if (o.PaletteOutput && !Execute("superfamiconv.exe", $"-i \"{o.InputFile}\" -F -M gb --out-palette-image \"_palette.png\""))
            {
                Console.WriteLine("ERROR: Palette image creation failed:");
                Console.Write(ProcessErrors.ToString());
                return;
            }

            if (!Execute("superfamiconv.exe", $"-i \"{o.InputFile}\" -v -M gb -t \"{TempTilesFile}\""))
            {
                Console.WriteLine("ERROR: Tile conversion failed:");
                Console.Write(ProcessErrors.ToString());
                return;
            }

            if (!Execute("superfamiconv.exe", $"-i \"{o.InputFile}\" -v -M gb -m \"{TempMapFile}\""))
            {
                Console.WriteLine("ERROR: Map conversion failed:");
                Console.Write(ProcessErrors.ToString());
                return;
            }

            int length;
            string outputPath;
            var sb = new StringBuilder();

            outputPath = Path.Combine(o.OutputFolder, $"{o.Name}_tiles.c");
            sb.Clear();
            AddHeader(sb, outputPath, true);
            using (var reader = new FileStream(TempTilesFile, FileMode.Open))
            {
                length = (int)reader.Length;
                sb.AppendLine($"const unsigned char {o.Name.ToUpper()}_TILE_DATA[] = {{");
                sb.AppendLine($"{"",4}// Tile 0");
                int b;
                for (var i = 0; (b = reader.ReadByte()) != -1; i++)
                {
                    if (i % Tiles_BytesPerLine == 0)
                    {
                        if (i > 0)
                        {
                            sb.AppendLine(",");
                            if (i % 16 == 0)
                            {
                                sb.AppendLine($"{"",4}// Tile {i / 16}");
                            }
                        }
                        sb.Append("".PadLeft(4));
                    }
                    else
                    {
                        sb.Append(", ");
                    }
                    sb.Append($"0x{b:X2}");

                }
                sb.AppendLine();
                sb.AppendLine("};");
            }
            File.Delete(TempTilesFile);
            WriteToFile(outputPath, sb);

            outputPath = Path.Combine(o.OutputFolder, $"{o.Name}_tiles.h");
            sb.Clear();
            AddHeader(sb, outputPath);

            sb.AppendLine($"#ifndef __MAP_{Path.GetFileName(outputPath).ToUpper().Replace(".", "_")}__");
            sb.AppendLine($"#define __MAP_{Path.GetFileName(outputPath).ToUpper().Replace(".", "_")}__");

            sb.AppendLine();
            sb.AppendLine($"#define {o.Name.ToUpper()}_TILE_COUNT {length / 16}");
            sb.AppendLine();
            sb.AppendLine($"extern const unsigned char {o.Name.ToUpper()}_TILE_DATA[];");

            sb.AppendLine();
            sb.AppendLine("#endif");
            WriteToFile(outputPath, sb);

            outputPath = Path.Combine(o.OutputFolder, $"{o.Name}_map.c");
            sb.Clear();
            AddHeader(sb, outputPath, true);
            using (var reader = new FileStream(TempMapFile, FileMode.Open))
            {
                sb.AppendLine($"const unsigned char {o.Name.ToUpper()}_MAP_DATA[] = {{");
                int b;
                for (var i = 0; (b = reader.ReadByte()) != -1; i++)
                {
                    if (i % Map_BytesPerLine == 0)
                    {
                        if (i > 0)
                        {
                            sb.AppendLine(",");
                        }
                        sb.Append("".PadLeft(4));
                    }
                    else
                    {
                        sb.Append(", ");
                    }
                    sb.Append($"0x{b:X2}");

                }
                sb.AppendLine();
                sb.AppendLine("};");
            }
            File.Delete(TempMapFile);
            WriteToFile(outputPath, sb);

            outputPath = Path.Combine(o.OutputFolder, $"{o.Name}_map.h");
            sb.Clear();
            AddHeader(sb, outputPath);

            sb.AppendLine($"#ifndef __MAP_{Path.GetFileName(outputPath).ToUpper().Replace(".", "_")}__");
            sb.AppendLine($"#define __MAP_{Path.GetFileName(outputPath).ToUpper().Replace(".", "_")}__");

            sb.AppendLine();
            sb.AppendLine($"#define {o.Name.ToUpper()}_MAP_WIDTH {mapWidth}");
            sb.AppendLine($"#define {o.Name.ToUpper()}_MAP_HEIGHT {mapHeight}");
            sb.AppendLine();
            sb.AppendLine($"extern const unsigned char {o.Name.ToUpper()}_MAP_DATA[];");

            sb.AppendLine();
            sb.AppendLine("#endif");
            WriteToFile(outputPath, sb);
        }

        private static void WriteToFile(string filePath, StringBuilder sb)
        {
            if (File.Exists(filePath))
            {
                File.Delete(filePath);
            }
            using (var writer = new StreamWriter(new FileStream(filePath, FileMode.CreateNew)))
            {
                writer.Write(sb.ToString());
            }
        }

        private static void Process_OutputDataReceived(object sender, DataReceivedEventArgs e)
        {
            ProcessOutput.AppendLine(e.Data);
        }

        private static void Process_ErrorDataReceived(object sender, DataReceivedEventArgs e)
        {
            ProcessErrors.AppendLine(e.Data);
        }

        static void Main(string[] args)
        {
            Parser.Default.ParseArguments<Options>(args)
                   .WithParsed(options => { Run(options); });
        }
    }
}
